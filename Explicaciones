El objetivo es manejarse con los hilos, los hilos, son una parte de un proceso, un proceso puede estar formado por diferentes hilos, que poseen diferentes datos, pero comparten herramientas comunes (como la memoria.)
Como en una cocina, (el proceso),donde se realizan muchisimas cosas pero donde comparten tenedores, cuchillos(la memoria).

La biblioteca fundamental es: # include <pthread.h>
Es la biblioteca que incluye las fucniones necesarias para los hilos.
Tus estructuras, contaran mÃ­nimo con dos elementos:
Una que represente el proceso. La mesa o la cocina.
Otra que represente cada hilo. Los filÃ³sofos.

La tabla es donde estaran los mutex (mutual exclusion)
Es un proceso de sincronizaciÃ³n, que bloquea datos o acceso a otros hilos
Si otro hilo intenta acceder, se queda esperando hasta que el mutex termine
Es una medida de proteccion de datos.

Un ejemplo: void	*routine(void *arg)
{
	t_philosopher	*philo;

	philo = (t_philosopher *)arg;
	pthread_mutex_lock(&philo->table->print_mutex);
	printf("FilÃ³sofo %d ha comenzado.\n", philo->id);
	pthread_mutex_unlock(&philo->table->print_mutex);
	return (NULL);
}

Esta funcion se ejecuta en todos los hilos, sin embargo, cuando se llega a lock
solo uno a uno podran usar printf, hasta que uno no lo desbloquee no avanza.

Es importante destacar, que los hilos son simultaneos, podria ocurrir y de hecho es la naturaleza del
proyecto que tras usar esa funcion, se imprima FilÃ³sofo 2 ha comenzado. FilÃ³sofo 1 ha comenzado.
estando en ordenes cambiados, es decir de manera desordenada, el ordenador asigna recurso segun los tenga libres, pero los hilos
en estos casos son simultaneos.

create and join -> Al crear un hilo, el sistema reserva recursoso para el hasta que alguien haga join.
Si nunca se hace join, y el hilo termina el sistema se queda colgado y el hilo se queda "zombie"




Debes implementar una simulaciÃ³n donde varios filÃ³sofos se sientan alrededor de una mesa y alternan entre tres acciones:
pensar, comer y dormir, utilizando recursos compartidos (tenedores)

Aprendes a usar la biblioteca de pthreads (pthread_create, pthread_join, pthread_mutex_*).

Comprendes quÃ© son data races, condiciones de carrera que pueden provocar errores difÃ­ciles de reproducir.

Te enfrentas a la necesidad de sincronizar recursos compartidos entre hilos (tenedores).

Debes cronometrar con precisiÃ³n cuÃ¡ndo un filÃ³sofo come, duerme o muere (gettimeofday, usleep).

Aprendes a controlar el orden y la simultaneidad de las acciones, evitando que los mensajes del log se entremezclen incorrectamente.

Organizar mÃºltiples hilos que comparten recursos te obliga a pensar en arquitectura de software mÃ¡s avanzada.

Manejas estructuras de datos para representar a los filÃ³sofos, sus estados y el entorno.

Cada filÃ³sofo es un hilo (thread).

Cada tenedor es un mutex compartido entre los filÃ³sofos adyacentes.

Los filÃ³sofos solo pueden comer si han adquirido los dos mutex (tenedores) que tienen a su izquierda y derecha.

Debes manejar el ciclo de vida de cada filÃ³sofo:

Piensa

Coge los tenedores (mutex lock)

Come (temporizador y logs)

Deja los tenedores (mutex unlock)

Duerme

Si un filÃ³sofo no ha comido en un tiempo time_to_die, muere y la simulaciÃ³n se detiene.

TambiÃ©n puedes implementar un argumento opcional: nÃºmero de veces que cada filÃ³sofo debe comer. Si todos lo logran, la simulaciÃ³n termina sin muertes.

No puedes usar variables globales.

No puede haber data races ni fugas de memoria.

Tienes que registrar con precisiÃ³n las acciones de cada filÃ³sofo con marcas de tiempo.

No puede haber mÃ¡s de 10ms entre que un filÃ³sofo muere y se imprime su mensaje de muerte.

 1. AnÃ¡lisis del enunciado y diseÃ±o inicial
Leer y entender el problema: reglas, condiciones de parada, formato de logs, uso de mutex.

Planificar las estructuras de datos necesarias (t_philosopher, t_table, t_fork, etc.).

Plan de sincronizaciÃ³n para evitar condiciones de carrera y deadlocks.

ğŸ“Tiempo estimado: 3-4 horas

ğŸ§  2. DefiniciÃ³n de estructuras y parsing de argumentos
Crear structs: filÃ³sofo, entorno/mesa, forks, mutex globales.

Parsear y validar argumentos de entrada, incluyendo el argumento opcional.

Crear funciÃ³n init_table para inicializar toda la estructura.

ğŸ“Tiempo estimado: 3 horas

ğŸ”§ 3. InicializaciÃ³n de mutex y recursos compartidos
Crear mutex por cada tenedor.

Crear mutex para la impresiÃ³n sincronizada.

Crear mutex para proteger acceso al tiempo de Ãºltima comida o al contador de comidas.

ğŸ“Tiempo estimado: 2-3 horas

ğŸ§µ 4. CreaciÃ³n de los hilos de filÃ³sofos
Crear funciÃ³n philosopher_routine que ejecuta el ciclo vida: pensar â†’ coger tenedores â†’ comer â†’ soltar tenedores â†’ dormir.

Crear los hilos con pthread_create y unirlos con pthread_join.

Asegurarse de que los filÃ³sofos estÃ©n sentados correctamente respecto a sus tenedores.

ğŸ“Tiempo estimado: 4-5 horas

ğŸ´ 5. ImplementaciÃ³n de la lÃ³gica de comida con mutex
FunciÃ³n para coger los tenedores con pthread_mutex_lock.

Registrar logs: has taken a fork, is eating.

Actualizar tiempo de Ãºltima comida con protecciÃ³n por mutex.

Dormir durante time_to_eat y soltar tenedores (pthread_mutex_unlock).

ğŸ“Tiempo estimado: 4 horas

ğŸ˜´ 6. LÃ³gica de dormir y pensar
Implementar usleep para time_to_sleep.

Registrar log de sueÃ±o y pensamiento.

AÃ±adir thinking al final para evitar bloqueos continuos de forks.

ğŸ“Tiempo estimado: 1-2 horas

ğŸ’€ 7. Implementar el monitor de muerte
Hilo separado que revisa constantemente si un filÃ³sofo ha pasado mÃ¡s de time_to_die sin comer.

ProtecciÃ³n con mutex al leer last_meal.

Finalizar la simulaciÃ³n e imprimir X died en cuanto ocurra.

Evitar imprimir estados despuÃ©s de la muerte.

ğŸ“Tiempo estimado: 3-4 horas

ğŸ§® 8. GestiÃ³n del argumento opcional number_of_times_each_philosopher_must_eat
AÃ±adir un contador en cada filÃ³sofo.

Hilo que verifica si todos los filÃ³sofos han comido al menos las veces necesarias.

Parar la simulaciÃ³n si se cumple esta condiciÃ³n antes de que alguien muera.

ğŸ“Tiempo estimado: 2 horas

ğŸ§¼ 9. Limpieza de memoria y destrucciÃ³n de mutex
Destruir todos los mutex (pthread_mutex_destroy).

Liberar memoria de structs dinÃ¡micos (filÃ³sofos, forks, etc.).

Verificar con Valgrind que no haya fugas de memoria.

ğŸ“Tiempo estimado: 1.5 horas

ğŸ“‹ 10. GestiÃ³n de errores, Makefile y pruebas finales
Crear un Makefile limpio con las normas: all, clean, fclean, re.

Manejar errores de argumentos y fallos en malloc, pthread_*, etc.

Crear un pequeÃ±o tester o script de pruebas.

Usar gettimeofday correctamente para calcular los logs en milisegundos.

ğŸ“Tiempo estimado: 3 horas
